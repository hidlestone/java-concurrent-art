## chapter05-Java中的锁

### 一、Lock接口
锁是用来控制多个线程访问共享资源的方式。
一般来说，一个锁能够防止多个线程同时 访问共享资源
（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。
在Lock接 口出现之前，Java程序是靠synchronized关键字实现锁功能的，
而Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，
它提供了与synchronized关键字类似的同步功 能，只是在使用时需要显式地获取和释放锁。

提供了synchronized不具有的特性：
```
1.尝试非阻塞地获取锁：tryLock()，调用方法后立刻返回。
2.能被中断地获取锁：lockInterruptibly():在锁的获取中可以中断当前线程,，同时锁会被释放。
3.超时获取锁:tryLock(time,unit)，超时返回。
```
Lock接口的实现基本都是通过聚合了一个同步器的子类来完成线程访问控制的。

不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，
异常抛出的同时，也会导致锁无故释放。

### 二、队列同步器
队列同步器AbstractQueuedSynchronizer是用来构建锁或其他同步组件的基础框架。
它使用一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。

同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。
理解两者的关系：
```
锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；
同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待和唤醒等底层操作。
```

#### 2.1、队列同步器的接口与示例
同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的
方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些
模板方法将会调用使用者重写的方法。

#### 2.2、队列同步器的实现分析
1、同步队列
通过一个FIFO双向队列来完成同步状态的管理，当前线程获取同步状态失败时，
同步器会将当前线程以及等待状态等信息
构造成一个Node并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，
会把首节点中的线程唤醒，使其再次尝试获取同步状态。

2、独占式同步状态获取和释放
```
 public final void acquire(int arg) {
        if (!tryAcquire(arg) &&acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
 }
```
代码分析：
首先尝试获取同步状态，如果获取失败，构造独占式同步节点并将其加入到节点的尾部，然后调用acquireQueued，使节点一死循环的方式去获取同步状态，如果获取不到就阻塞节点中的线程。
两个死循环：入队、入队后
只有前驱节点是头结点才能尝试获取同步状态，原因：
```
1. 头结点是成功获取到同步状态的节点，而头结点的线程释放了同步状态后，将会唤醒其后继节点，后继节点的线程
   被唤醒后需要检查自己的前驱节点是否为头节点。
2. 维护同步队列的FIFO原则
```
P128 图5-4节点自旋获取同步状态 图5-5独占式同步状态获取流程

总结：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋，
移出队列（停止自旋）的条件是前驱节点是头结点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease
方法释放同步状态，然后唤醒头结点的后继节点

3、共享式同步状态的获取与释放
共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。
共享式访问资源时，其他共享式的访问均被允许，而独占式访问被阻塞。独占式访问资源时，同一时刻其他访问均被阻塞。

4、共享式超时获取同步状态
通过调用同步器的doAcquireNanos(int arg,long nanosTimeout)方法可以超时获取同步状态，
即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。
该方法提供了传统Java同步操作（比如synchronized关键字）所不具备的特性。

5、自定义组件 —— TwinsLock
chapter05.TwinsLock

### 三、重入锁
重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。

synchronized关键字隐式地支持重入。比如一个synchronized修饰的递归方法，
在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁，而不像Mutex由于获
取了锁，而在下一次获取锁时出现阻塞自己的情况。

ReentrantLock不像synchronized隐式支持，在调用lock方法时，已经获取到锁的线程，能够再次调用lock方法获取锁而不被阻塞。
事实上，公平的锁机制往往没有非公平的效率高，但是公平锁的好处在于：公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足。

1、重入的实现
重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题。
1）线程再次获取锁
2）锁的最终释放

2、公平与非公平获取锁的区别
公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合 请求的绝对时间顺序，也就是FIFO。
```
公平锁：CAS成功，且是队列的首节点
非公平锁：CAS成功即可
```
重入锁的默认实现是非公平锁，原因：虽然会导致饥饿，但是非公平锁的的开销少（线程切换次数少），从而可以有更高的吞吐量。

### 四、读写锁（ReentrantReadWriteLock）
之前提到锁（如Mutex和ReentrantLock）基本都是排他锁，这些锁在同一时刻只允许一个线
程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读
线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写
锁，使得并发性相比一般的排他锁有了很大提升。

#### 4.1、读写锁的接口与示例
chapter05.Cache

#### 4.2、读写锁的实现分析
来分析ReentrantReadWriteLock的实现，主要包括：读写状态的设计、写锁的获取与释
放、读锁的获取与释放以及锁降级（以下没有特别说明读写锁均可认为是 ReentrantReadWriteLock）。

##### 1、读写状态的设计
读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。 

读写锁的自定义同步器需要在同步状态（一个int值）上维护多个读线程和一个写线程的状态，
高16位表示读，低16位表示写。

##### 2、写锁的获取和释放
写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当 前线程在获取写锁时，
读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程， 则当前线程进入等待状态，

##### 3、读锁的获取和释放
在没有其他写线程访问时，读锁总会被成功地获取。如果写锁已经被其他线程获取，则进入等待状态。
读状态的线程安全由CAS保证。

##### 4、锁降级（写锁降级成为读锁）
定义：把持住写锁，再获取到读锁，随后释放写锁的过程
```
writeLock.lock();
readLock.lock();
writeLock.unlock();
```
锁降级中读锁获取的必要性：
>为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程获取了写锁
 并修改了数据，那么当前线程无法感知到数据的更新.如果当前线程获取读锁，则另一个线程会被阻塞，
 直到当前线程使用数据并释放锁之后，另一个线程才能获取写锁进行数据更新。
 
### 五、LockSupport工具
当需要阻塞或唤醒一个线程的时候，都会使用LockSupport工具类来完成相应 工作。
LockSupport定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，
而LockSupport也成为构建同步组件的基础工具。

### 六、Condition接口
任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），
主要包括wait()、 wait(long timeout)、notify()以及notifyAll()方法，
这些方法与synchronized同步关键字配合，可以 实现等待/通知模式。
Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等 待/通知模式，
但是这两者在使用方式以及功能特性上还是有差别的。

#### 6.1、Condition接口与示例
Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到 Condition对象关联的锁。
Condition对象是由Lock对象（调用Lock对象的newCondition()方法）创 建出来的，换句话说，Condition是依赖Lock对象的。

#### 6.2、Condition的实现分析
ConditionObject是同步器AbstractQueuedSynchronizer的内部类，
因为Condition的操作需要获取相关联的锁，所以作为同步器的内部类也较为合理。
每个Condition对象都包含着一个队 列（以下称为等待队列），该队列是Condition对象实现等待/通知功能的关键。

##### 1、等待队列
等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是 在Condition对象上等待的线程，
如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。
##### 2、等待
调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释 放锁，
同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。
##### 3、通知
调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点（首节点），
在唤醒节点之前，会将节点移到同步队列中。
